# Bloom Filter：概率型数据结构

## 核心设计

```
┌────────────────────────────────────────────────────────┐
│ 用极小空间判断"可能存在"或"一定不存在"                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  位数组: [0,0,0,0,0,0,0,0,0,0]                         │
│                                                        │
│  插入 "apple": hash1=2, hash2=5, hash3=8               │
│           [0,0,1,0,0,1,0,0,1,0]                        │
│                                                        │
│  查询 "banana": hash1=1, hash2=5, hash3=9              │
│           位置 1 是 0 → 一定不存在                      │
│                                                        │
│  查询 "cherry": 所有位置都是 1                          │
│           → 可能存在（有误判率）                         │
│                                                        │
│  特点：                                                 │
│  • 假阳性：可能误判为存在（可控制概率）                   │
│  • 假阴性：绝不会误判为不存在                           │
│  • 不能删除元素（标准实现）                             │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 工作原理

```
┌────────────────────────────────────────────────────────┐
│ 插入操作                                               │
├────────────────────────────────────────────────────────┤
│                                                        │
│  element ──┬── hash1() ──► 位置 2 ──► 设为 1           │
│            ├── hash2() ──► 位置 5 ──► 设为 1           │
│            └── hash3() ──► 位置 8 ──► 设为 1           │
│                                                        │
│  位数组: [0,0,1,0,0,1,0,0,1,0]                         │
│              ↑     ↑     ↑                             │
│                                                        │
└────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────┐
│ 查询操作                                               │
├────────────────────────────────────────────────────────┤
│                                                        │
│  element ──┬── hash1() ──► 检查位置 ──┐               │
│            ├── hash2() ──► 检查位置 ──┼─► 全为1？      │
│            └── hash3() ──► 检查位置 ──┘    │           │
│                                            │           │
│                               ┌────────────┼───┐       │
│                               │ Yes        │ No│       │
│                               ▼            ▼   │       │
│                          可能存在      一定不存在       │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 参数设计

```
┌────────────────────────────────────────────────────────┐
│ 误判率公式                                              │
├────────────────────────────────────────────────────────┤
│                                                        │
│  p ≈ (1 - e^(-kn/m))^k                                │
│                                                        │
│  m = 位数组大小                                        │
│  n = 元素数量                                          │
│  k = 哈希函数数量                                      │
│  p = 误判率                                            │
│                                                        │
│  最优哈希函数数量：k = (m/n) * ln(2) ≈ 0.693 * (m/n)  │
│                                                        │
│  常用配置示例：                                         │
│  • 1% 误判率：每元素约 10 bits，7 个哈希函数            │
│  • 0.1% 误判率：每元素约 15 bits，10 个哈希函数         │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 实际应用

### 1. 浏览器恶意 URL 检测

```
┌────────────────────────────────────────────────────────┐
│ Google Safe Browsing                                   │
├────────────────────────────────────────────────────────┤
│                                                        │
│  问题：检查 URL 是否在恶意网站列表中                     │
│       列表有数百万条，不可能全部下载                     │
│                                                        │
│  解决：                                                 │
│  1. 本地存储 Bloom Filter（几 MB）                     │
│  2. 访问 URL 时先查本地 Bloom Filter                   │
│  3. 如果"可能存在"，再请求服务器确认                    │
│  4. 如果"一定不存在"，直接放行                         │
│                                                        │
│  效果：99%+ 的请求无需访问服务器                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 2. 数据库避免磁盘查询

```
┌────────────────────────────────────────────────────────┐
│ LSM-Tree 中的 Bloom Filter                             │
├────────────────────────────────────────────────────────┤
│                                                        │
│  问题：查询的 key 可能不存在于某个 SSTable              │
│       不必要的磁盘读取                                  │
│                                                        │
│  解决：                                                 │
│  每个 SSTable 关联一个 Bloom Filter                    │
│                                                        │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐               │
│  │ SSTable │  │ SSTable │  │ SSTable │               │
│  │ + BF    │  │ + BF    │  │ + BF    │               │
│  └────┬────┘  └────┬────┘  └────┬────┘               │
│       │            │            │                     │
│  BF: 不存在    BF: 可能存在   BF: 不存在               │
│   (跳过)        (读取磁盘)    (跳过)                   │
│                                                        │
│  LevelDB, RocksDB, Cassandra 等都使用                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 3. 缓存穿透防护

```
┌────────────────────────────────────────────────────────┐
│ 防止查询不存在的数据                                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  攻击：恶意查询大量不存在的 ID                          │
│       每次都穿透缓存，打到数据库                        │
│                                                        │
│  解决：                                                 │
│                                                        │
│  请求 ──► Bloom Filter ──► 不存在 ──► 直接返回空        │
│               │                                        │
│               └──► 可能存在 ──► 查缓存/数据库           │
│                                                        │
│  所有有效 ID 加入 Bloom Filter                         │
│  无效请求被快速拦截                                     │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 4. 分布式系统

```
┌────────────────────────────────────────────────────────┐
│ 快速判断数据在哪个节点                                  │
├────────────────────────────────────────────────────────┤
│                                                        │
│  场景：分布式缓存，数据分布在多个节点                    │
│                                                        │
│  每个节点维护自己数据的 Bloom Filter                   │
│  查询时先问 Bloom Filter，再访问具体节点                │
│                                                        │
│  Node A ──► BF: [user1, user2, ...]                   │
│  Node B ──► BF: [user3, user4, ...]                   │
│  Node C ──► BF: [user5, user6, ...]                   │
│                                                        │
│  查询 user3:                                           │
│  BF_A: 不存在 (跳过)                                   │
│  BF_B: 可能存在 (访问 Node B)                         │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 变种

### Counting Bloom Filter

```
┌────────────────────────────────────────────────────────┐
│ 支持删除操作                                           │
├────────────────────────────────────────────────────────┤
│                                                        │
│  标准 BF：每个位置是 0/1                               │
│  计数 BF：每个位置是计数器                             │
│                                                        │
│  插入：计数器 +1                                       │
│  删除：计数器 -1                                       │
│  查询：所有位置 > 0                                    │
│                                                        │
│  缺点：空间增加 4-8 倍                                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Cuckoo Filter

```
┌────────────────────────────────────────────────────────┐
│ 更现代的替代方案                                        │
├────────────────────────────────────────────────────────┤
│                                                        │
│  优点：                                                 │
│  • 支持删除                                            │
│  • 空间效率更高（同等误判率下）                         │
│  • 查询更快（更少的内存访问）                           │
│                                                        │
│  原理：                                                 │
│  • 使用 Cuckoo Hashing                                │
│  • 存储 fingerprint 而非位                            │
│  • 两个候选位置，冲突时"踢走"现有元素                   │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 代码实现

```python
import mmh3  # MurmurHash3
from bitarray import bitarray

class BloomFilter:
    def __init__(self, size: int, hash_count: int):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)

    def add(self, item: str):
        for i in range(self.hash_count):
            index = mmh3.hash(item, i) % self.size
            self.bit_array[index] = 1

    def contains(self, item: str) -> bool:
        for i in range(self.hash_count):
            index = mmh3.hash(item, i) % self.size
            if not self.bit_array[index]:
                return False  # 一定不存在
        return True  # 可能存在

# 使用
bf = BloomFilter(size=1000, hash_count=7)
bf.add("apple")
bf.add("banana")

print(bf.contains("apple"))   # True (确实存在)
print(bf.contains("orange"))  # False (一定不存在)
print(bf.contains("cherry"))  # True/False (可能误判)
```

## 设计启示

1. **空间换准确性** - 接受小概率误判，换取极大空间节省
2. **快速否定** - "一定不存在"比"可能存在"更有价值
3. **分层过滤** - 先用廉价检查过滤大部分，再用精确检查
4. **概率数据结构** - 有时候"大概对"比"绝对对"更实用
