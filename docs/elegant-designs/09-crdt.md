# CRDT：无冲突复制数据类型

## 核心设计

```
┌────────────────────────────────────────────────────────┐
│ CRDT：分布式系统的"最终一致"魔法                        │
├────────────────────────────────────────────────────────┤
│                                                        │
│  问题：多个节点同时修改，如何合并？                       │
│                                                        │
│  传统方案：                                             │
│  • 锁 → 性能差，单点故障                               │
│  • 共识算法 → 延迟高，需要多数节点在线                   │
│                                                        │
│  CRDT 方案：                                           │
│  • 设计特殊数据结构                                    │
│  • 任何顺序合并，结果相同                               │
│  • 无需协调，离线也能工作                               │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 数学基础

```
┌────────────────────────────────────────────────────────┐
│ 半格（Semilattice）属性                                 │
├────────────────────────────────────────────────────────┤
│                                                        │
│  合并操作 ⊔ 满足：                                     │
│                                                        │
│  1. 交换律：a ⊔ b = b ⊔ a                             │
│  2. 结合律：(a ⊔ b) ⊔ c = a ⊔ (b ⊔ c)                 │
│  3. 幂等性：a ⊔ a = a                                  │
│                                                        │
│  → 任何顺序合并，任何重复合并，结果都相同                │
│  → 不需要协调，最终一定收敛                             │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 常见 CRDT 类型

### G-Counter（只增计数器）

```
┌────────────────────────────────────────────────────────┐
│ 每个节点维护自己的计数，合并时取最大值                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Node A: {A: 5, B: 0, C: 0}  本地 +5                  │
│  Node B: {A: 0, B: 3, C: 0}  本地 +3                  │
│  Node C: {A: 0, B: 0, C: 7}  本地 +7                  │
│                                                        │
│  合并：{A: 5, B: 3, C: 7}                              │
│  总计：5 + 3 + 7 = 15                                 │
│                                                        │
└────────────────────────────────────────────────────────┘
```

```typescript
class GCounter {
  private counts: Map<string, number> = new Map();

  constructor(private nodeId: string) {}

  increment(n: number = 1) {
    const current = this.counts.get(this.nodeId) || 0;
    this.counts.set(this.nodeId, current + n);
  }

  value(): number {
    let sum = 0;
    for (const count of this.counts.values()) {
      sum += count;
    }
    return sum;
  }

  merge(other: GCounter) {
    for (const [nodeId, count] of other.counts) {
      const current = this.counts.get(nodeId) || 0;
      this.counts.set(nodeId, Math.max(current, count));
    }
  }
}
```

### PN-Counter（可增可减计数器）

```
┌────────────────────────────────────────────────────────┐
│ 两个 G-Counter：一个记录增，一个记录减                   │
├────────────────────────────────────────────────────────┤
│                                                        │
│  P (positive): {A: 10, B: 5}    增加的总量              │
│  N (negative): {A: 2, B: 1}     减少的总量              │
│                                                        │
│  值 = sum(P) - sum(N) = 15 - 3 = 12                   │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### LWW-Register（最后写入胜出）

```
┌────────────────────────────────────────────────────────┐
│ 带时间戳的值，时间戳大的胜出                             │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Node A: (value="X", timestamp=100)                   │
│  Node B: (value="Y", timestamp=150)                   │
│                                                        │
│  合并：(value="Y", timestamp=150)                     │
│                                                        │
│  注意：需要时钟同步，可能丢失并发写入                    │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### G-Set（只增集合）

```
┌────────────────────────────────────────────────────────┐
│ 只能添加元素，合并时取并集                               │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Node A: {apple, banana}                              │
│  Node B: {banana, cherry}                             │
│                                                        │
│  合并：{apple, banana, cherry}                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 2P-Set（两阶段集合）

```
┌────────────────────────────────────────────────────────┐
│ 两个 G-Set：一个记录添加，一个记录删除                   │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Add Set:    {a, b, c, d}                             │
│  Remove Set: {b, d}                                   │
│                                                        │
│  当前集合 = Add - Remove = {a, c}                     │
│                                                        │
│  限制：删除的元素不能再添加（墓碑永存）                  │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### OR-Set（观察-删除集合）

```
┌────────────────────────────────────────────────────────┐
│ 每次添加生成唯一标签，删除移除已见的标签                  │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Node A: add("x") → {(x, uuid1)}                      │
│  Node B: add("x") → {(x, uuid2)}                      │
│                                                        │
│  合并：{(x, uuid1), (x, uuid2)}                       │
│                                                        │
│  Node A: remove("x") → 移除 uuid1                     │
│  结果：{(x, uuid2)} → "x" 仍存在                      │
│                                                        │
│  添加胜过并发的删除（Add-Wins 语义）                    │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 实际应用

### Figma 多人协作

```
┌────────────────────────────────────────────────────────┐
│ Figma 使用 CRDT 实现实时协作                            │
├────────────────────────────────────────────────────────┤
│                                                        │
│  • 每个对象有唯一 ID                                   │
│  • 属性使用 LWW-Register                              │
│  • 图层顺序使用分数索引                                 │
│  • 离线编辑，上线后自动合并                             │
│                                                        │
│  用户 A: 移动矩形到 (100, 100)                         │
│  用户 B: 移动矩形到 (200, 200)                         │
│                                                        │
│  结果：时间戳大的胜出，两人看到相同结果                  │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Redis CRDT

```
┌────────────────────────────────────────────────────────┐
│ Redis Enterprise 的 CRDT 数据类型                      │
├────────────────────────────────────────────────────────┤
│                                                        │
│  • CRDT Counter：分布式计数器                          │
│  • CRDT Set：分布式集合                                │
│  • CRDT String：最后写入胜出字符串                     │
│                                                        │
│  跨数据中心复制，无冲突合并                             │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### Automerge / Yjs

```typescript
// Automerge 示例
import * as Automerge from 'automerge'

// 创建文档
let doc1 = Automerge.from({ todos: [] })

// 节点 1 修改
doc1 = Automerge.change(doc1, doc => {
  doc.todos.push({ text: 'Buy milk', done: false })
})

// 节点 2 独立修改
let doc2 = Automerge.clone(doc1)
doc2 = Automerge.change(doc2, doc => {
  doc.todos.push({ text: 'Buy eggs', done: false })
})

// 合并
let merged = Automerge.merge(doc1, doc2)
// merged.todos = [{text: 'Buy milk'}, {text: 'Buy eggs'}]

// 即使顺序不同，合并结果也相同
```

```typescript
// Yjs 示例（协作文本编辑）
import * as Y from 'yjs'

const doc = new Y.Doc()
const ytext = doc.getText('content')

// 插入文本
ytext.insert(0, 'Hello ')
ytext.insert(6, 'World')

// 同步更新
doc.on('update', update => {
  // 广播给其他节点
  broadcastUpdate(update)
})

// 应用远程更新
Y.applyUpdate(doc, remoteUpdate)
```

## CRDT vs OT

```
┌────────────────────────────────────────────────────────┐
│ CRDT vs Operational Transformation                     │
├────────────────────────────────────────────────────────┤
│                                                        │
│  OT (Google Docs 使用):                               │
│  • 变换并发操作，保持意图                               │
│  • 需要中央服务器协调                                   │
│  • 实现复杂，容易出错                                   │
│                                                        │
│  CRDT:                                                │
│  • 数据结构自带合并语义                                 │
│  • 无需协调，P2P 友好                                  │
│  • 实现相对简单，数学保证正确性                         │
│  • 可能有更多元数据开销                                 │
│                                                        │
│  趋势：新系统倾向使用 CRDT                             │
│  • Figma、Linear、Notion 等                           │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 设计启示

1. **设计决定并发语义** - 数据结构本身决定冲突解决
2. **最终一致足够** - 不需要强一致也能工作
3. **元数据换协调** - 存储额外信息，避免通信
4. **单调性** - 状态只增不减（或通过抵消实现减）
5. **本地优先** - 本地操作即时响应，后台同步
