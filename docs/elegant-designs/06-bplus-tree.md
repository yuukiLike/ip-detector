# B+ 树：数据库索引的基石

## 核心设计

```
┌────────────────────────────────────────────────────────┐
│ 为磁盘 I/O 优化的数据结构                               │
├────────────────────────────────────────────────────────┤
│                                                        │
│           ┌───────────────┐                            │
│           │  [30 | 60]    │  ← 内部节点只存键           │
│           └───┬───┬───┬───┘                            │
│         ┌─────┘   │   └─────┐                          │
│    ┌────▼───┐ ┌───▼───┐ ┌───▼────┐                    │
│    │10|20|30│→│40|50|60│→│70|80|90│ ← 叶子节点链表     │
│    └────────┘ └───────┘ └────────┘                     │
│                                                        │
│  • 高扇出：减少树高度，减少磁盘读取                      │
│  • 叶子链表：范围查询极快                               │
│  • 节点大小 = 磁盘页大小（4KB/16KB）                    │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 为什么不用二叉树？

```
┌────────────────────────────────────────────────────────┐
│ 二叉搜索树 vs B+ 树                                    │
├────────────────────────────────────────────────────────┤
│                                                        │
│  二叉树：100万条记录 → 树高约 20                        │
│         每次查询 20 次磁盘 I/O                         │
│                                                        │
│  B+ 树：100万条记录，扇出 100 → 树高 3                 │
│         每次查询 3 次磁盘 I/O                          │
│                                                        │
│  磁盘 I/O 是瓶颈：                                     │
│  • 内存访问：~100ns                                    │
│  • SSD 随机读：~100μs (1000x)                         │
│  • HDD 随机读：~10ms (100000x)                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## B+ 树 vs B 树

```
┌────────────────────────────────────────────────────────┐
│ B 树：                                                 │
│                                                        │
│       ┌─────────────────┐                              │
│       │ 30:data | 60:data│  ← 内部节点也存数据          │
│       └───┬───────┬───┘                               │
│                                                        │
│ B+ 树：                                                │
│                                                        │
│       ┌─────────────────┐                              │
│       │    30 | 60      │  ← 内部节点只存键            │
│       └───┬───────┬───┘                               │
│      ┌────▼────┐ ┌▼────┐                              │
│      │10:d|20:d│→│40:d │  ← 数据只在叶子节点           │
│      └─────────┘ └─────┘   叶子节点形成链表            │
│                                                        │
│ B+ 树优势：                                            │
│ • 内部节点更小 → 扇出更高 → 树更矮                     │
│ • 范围查询：遍历叶子链表，无需回溯                      │
│ • 所有查询路径长度相同，性能稳定                        │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 数据库中的实现

```sql
-- MySQL InnoDB
-- 主键索引（聚簇索引）：叶子节点存储完整行数据
-- 二级索引：叶子节点存储主键值

CREATE TABLE users (
    id INT PRIMARY KEY,          -- 聚簇索引
    email VARCHAR(255),
    INDEX idx_email (email)      -- 二级索引
);

-- 查询过程
SELECT * FROM users WHERE email = 'user@example.com';
-- 1. 在 idx_email 中查找 email，获取 id
-- 2. 在主键索引中查找 id，获取完整行（回表）

-- 覆盖索引：避免回表
CREATE INDEX idx_email_id ON users(email, id);
SELECT id FROM users WHERE email = 'user@example.com';
-- 索引中直接包含所需数据，无需回表
```

## 页分裂与合并

```
┌────────────────────────────────────────────────────────┐
│ 页分裂（插入导致节点满）                                │
├────────────────────────────────────────────────────────┤
│                                                        │
│  Before:  [10|20|30|40|50]  (已满)                    │
│                                                        │
│  Insert 35:                                           │
│                                                        │
│  After:   [10|20|30] → [35|40|50]                    │
│           父节点新增指针                               │
│                                                        │
│  顺序插入优化：                                        │
│  • 自增主键 → 总是在最后插入 → 最小化分裂              │
│  • UUID 主键 → 随机插入 → 大量分裂 → 性能差            │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 查询类型与索引

```sql
-- 点查询：O(log n)
SELECT * FROM users WHERE id = 100;

-- 范围查询：O(log n + k)，k 是结果数量
SELECT * FROM users WHERE id BETWEEN 100 AND 200;
-- 利用叶子节点链表顺序扫描

-- 最左前缀匹配
CREATE INDEX idx_abc ON t(a, b, c);

SELECT * FROM t WHERE a = 1;                    -- ✅ 使用索引
SELECT * FROM t WHERE a = 1 AND b = 2;          -- ✅ 使用索引
SELECT * FROM t WHERE a = 1 AND b = 2 AND c = 3; -- ✅ 使用索引
SELECT * FROM t WHERE b = 2;                    -- ❌ 不使用索引
SELECT * FROM t WHERE a = 1 AND c = 3;          -- 部分使用（只用 a）

-- 排序优化
SELECT * FROM t WHERE a = 1 ORDER BY b;         -- 索引已排序，无需额外排序
```

## 索引设计原则

```
┌────────────────────────────────────────────────────────┐
│ 索引选择性 = 不同值数量 / 总行数                        │
├────────────────────────────────────────────────────────┤
│                                                        │
│  高选择性（好）：email、phone、uuid                     │
│  低选择性（差）：gender、status、is_deleted            │
│                                                        │
│  组合索引顺序：                                         │
│  1. 等值查询的列放前面                                  │
│  2. 选择性高的列放前面                                  │
│  3. 范围查询的列放最后                                  │
│                                                        │
│  示例：WHERE status = 'active' AND created_at > ?      │
│  索引：(status, created_at) 而非 (created_at, status) │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 其他索引类型

```
┌────────────────────────────────────────────────────────┐
│ 索引类型对比                                           │
├────────────────────────────────────────────────────────┤
│                                                        │
│  B+ 树索引：                                           │
│  • 范围查询、排序、最左前缀                             │
│  • 大多数场景的默认选择                                 │
│                                                        │
│  哈希索引：                                            │
│  • 只支持等值查询 O(1)                                 │
│  • 不支持范围、排序                                    │
│  • Memory 引擎默认                                     │
│                                                        │
│  全文索引（倒排索引）：                                 │
│  • 文本搜索                                            │
│  • 分词 → 词 → 文档列表                                │
│                                                        │
│  R-Tree：                                              │
│  • 空间索引（地理位置）                                 │
│  • 范围框查询                                          │
│                                                        │
│  Bitmap 索引：                                         │
│  • 低基数列（性别、状态）                               │
│  • OLAP 场景                                           │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 执行计划分析

```sql
-- MySQL
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 关键字段：
-- type: const > eq_ref > ref > range > index > ALL
-- key: 使用的索引
-- rows: 预估扫描行数
-- Extra: Using index（覆盖索引）、Using filesort（需要排序）

-- PostgreSQL
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
-- 显示实际执行时间和行数
```

## 设计启示

1. **适配硬件** - 节点大小匹配磁盘页
2. **高扇出** - 减少树高度，减少 I/O
3. **局部性** - 叶子链表提供顺序访问
4. **平衡** - 自平衡保证最坏情况性能
5. **分离** - 索引与数据分离（非聚簇）或一体（聚簇）
